<!DOCTYPE html><html lang="en" class="post"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Riley Shaw | Stealing History With CSS Binary Trees</title><meta name="description" content="Riley Shaw | A designer and programmer"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="msapplication-TileColor" content="#44CCAA"><meta name="msapplication-TileImage" content="/favicon-144.png"><link rel="apple-touch-icon-precomposed" href="/favicon-152.png"><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/main.aac3.css"><link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400|Droid+Serif:400,700,400italic|Raleway:800|Montserrat:700|Inconsolata:400,700" rel="dns-prefetch preconnect stylesheet" type="text/css"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-48709534-1', 'rileyjshaw.com');
  ga('require', 'displayfeatures');
  ga('send', 'pageview');</script></head><body><div id="drawer-nav-overlay"></div><header id="top-nav"><a href="/" id="drawer-nav-link" class="logo" data-no-instant>R</a><nav><ul></ul></nav></header><nav id="drawer-nav" role="navigation"><ul><li><a href="/" class="home-block"><div class="vcent"></div><span>Home</span></a></li><li><a href="/about" class="about-block"><div class="vcent"></div><span>About</span></a></li><li><a href="/blog" class="blog-block"><div class="vcent"></div><span>Blog</span></a></li><li><a href="/lab" class="lab-block"><div class="vcent"></div><span>Lab</span></a></li></ul></nav><div class="post-content"><div class="inner"><article><h1>Stealing history with CSS binary trees</h1><p class="date">Posted 4 years and 11 months ago</p><p><strong>UPDATE 2015-01-21</strong>: <em>Since writing this post, Chrome and FF have changed their alpha-blending functions. Demos likely won’t work anymore. This is good news!!</em></p><p>History-sniffing attacks let front-end code peek at other sites you’ve visited. They can be used to target ads, steal information, or discern your identity. Creepy.</p><p>Historically, one of the most popular history-sniffing techniques was to style <code class="language-css">:visited</code> links using CSS and check their color with JavaScript. Major browsers started implementing <a href="https://hacks.mozilla.org/2010/03/privacy-related-changes-coming-to-css-vistited/">privacy changes</a> to address this attack in 2010.<sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup> As a result, JavaScript’s <code class="language-javascript">getComputedStyle</code> now returns unvisited styles for visited sites.</p><p>Even with these limitations there are a number of ways to scrape a user’s history. The remainder of this article describes a combination of tricks used to do so. The outcome is a proof-of-concept <a href="/visited-vectors/reaction/">history-sniffing game</a>.</p><h2 id="trick-1-clicking-colors">Trick #1: Clicking colors</h2><p>Though <code class="language-javascript">getComputedStyle</code> is a dead-end, sniffers can trick <em>users</em> into telling a script which links they’ve visited. <a href="http://tinsnail.neocities.org/">This demo</a> is the clearest implementation that I’ve seen; the site shows a grid of styled links and asks you to click the red ones.</p><p>I saw the demo above while working on an unrelated game. The game asked players to hit the spacebar when a box turned red.</p><figure><img src="/images/reaction1.7cb3.png" width="120px" alt="Interface for a simple reaction game"></figure><p><em>“Hey”</em>, I thought to myself, <em>“this game could be so much more sneaky!”</em></p><p>I swapped the box out for a stack of links and styled <code class="language-css">:visited</code> to <code class="language-css">background-color:red</code>. It was totally evil and awesome and ready to go!</p><figure><img src="/images/reaction2.b984.png" alt="Score displaying with red background" width="120"></figure><p>…almost.</p><figure><img src="/images/reaction3.e91e.png" alt="Score displaying with white background" width="120"></figure><p>Since I didn’t know when the square was red I was <em>always</em> displaying a score, even on misfires. I’d broken the game.</p><h2 id="trick-2-like-a-polar-bear-in-a-snowstorm">Trick #2: Like a polar bear in a snowstorm</h2><p>Another popular history-sniffing trick is to hide non-<code class="language-css">:visited</code> links by making them appear the same color as the background. <a href="http://www.ieee-security.org/TC/SP2011/PAPERS/2011/paper010.pdf">This paper</a> shows some clever examples, as does <a href="http://lcamtuf.blogspot.ca/2013/05/some-harmless-old-fashioned-fun-with-css.html">this game</a>. By simply flipping this technique we can hide score text over the white non-<code class="language-css">:visited</code> links. For extra fanciness, we add a red text layer to indicate failure.</p><figure><img src="/images/reaction4.d9f6.png" alt="Text blending in with same-colored backgrounds" width="482"><figcaption>White and red text are appropriately hidden on their respective backgrounds</figcaption></figure><p>With just the first two tricks we have a <a href="/visited-vectors/reaction/linear.html">functioning game</a>. Probing one link at a time covers ~60 links per minute and provides solid user insight. Tricks #3 and #4 improve our search algorithm,<sup id="fnref:2"><a href="#fn:2" class="footnote">2</a></sup> increasing read-speed by ~10x.</p><h2 id="trick-3-css-decoders">Trick #3: CSS decoders</h2><p><a href="http://lcamtuf.coredump.cx/css_calc/">This paper</a> builds an n-input OR gate in CSS using alpha-blending rounding errors. I’ve embedded my own cross-browser version below; click Result to see it in action:</p><div data-height="268" data-theme-id="5323" data-slug-hash="CjiKf" data-default-tab="css" data-user="rileyjshaw" class="codepen"><pre><code>$in: 0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0

.container
  div
    opacity: 0.004
    background: white

  @for $b from 1 through length($in)
    @if nth($in,$b) == 1
      .l#{$b}
        background: red

// Everything below this is beside the point...
.container
  position: fixed
  top: 50%
  left: 50%
  height: 120px
  width: 120px
  margin: -62px
  border: 4px solid black
  font: bold 32px/#{60px} sans-serif
  text-align: center
  color: red

  div
    position: absolute
    top: 0
    left: 0
    height: 100%
    width: 100%

p
  position: relative

.on
  color: white
</code></pre><p>See the Pen <a href="http://codepen.io/rileyjshaw/pen/CjiKf/">n-input OR gate in CSS</a> by Riley Shaw (<a href="http://codepen.io/rileyjshaw">@rileyjshaw</a>) on <a href="http://codepen.io">CodePen</a>.</p></div><script async src="//assets.codepen.io/assets/embed/ei.js"></script><p>An OR gate is “on” if any of its inputs are “on”. We can use this to probe n links<sup id="fnref:3"><a href="#fn:3" class="footnote">3</a></sup> at once by stacking them together. Now if a user sees red and hits the spacebar we know that one of the links in the group has been visited.</p><h2 id="trick-4-slow-recursion">Trick #4: Slow recursion</h2><p>This trick figures out <em>which</em> of a group’s links have been visited. We can divide each group into a binary tree for searching but can’t rely on simple conditional search algorithms<sup id="fnref:4"><a href="#fn:4" class="footnote">4</a></sup> since we’re rate-limited by the user’s reaction time.<sup id="fnref:5"><a href="#fn:5" class="footnote">5</a></sup> This means that we must maintain state in our own stack.</p><p>If you’re curious about specifics, <a href="https://github.com/rileyjshaw/visited-vectors/">the whole project is on GitHub</a>. Since the code’s cluttered with game logic I’ve written a <a href="https://gist.github.com/rileyjshaw/02c5a8135dd3b1368918">stripped-down version of Trick #4</a>.</p><h2 id="trick-5-automation">Trick #5: Automation</h2><p>Despite the gains achieved in Tricks #3 and #4, relying on user input will never be as fast as the old <code class="language-javascript">getComputedStyle</code> method.<sup id="fnref:6"><a href="#fn:6" class="footnote">6</a></sup> Since we can no-longer automate color tests, is it possible to avoid looking at color altogether?<sup id="fnref:7"><a href="#fn:7" class="footnote">7</a></sup> Testing 16 links requires alpha-blending 4,096 elements at each step.<sup id="fnref:8"><a href="#fn:8" class="footnote">8</a></sup> This is a non-trivial operation; can we infer what the browser is drawing by testing render and redraw times?</p><p>This is a <a href="http://carlos.bueno.org/2011/10/timing.html">timing attack</a> and I’m not the first to apply it to this context. <a href="http://www.contextis.com/documents/2/Browser_Timing_Attacks.pdf">Pixel Perfect Timing Attacks with HTML5</a> is a <em>fantastic</em> white paper by Context Information Security on the subject. They were able to successfully implement timing attacks using CSS’s <code class="language-css">text-shadow</code> property and SVG filters.<sup id="fnref:9"><a href="#fn:9" class="footnote">9</a></sup> So, there’s the answer. Now go read that paper.</p><h2 id="conclusion">Conclusion</h2><p>I won’t be taking over the world with this project<sup id="fnref:10"><a href="#fn:10" class="footnote">10</a></sup> but it demonstrates some interesting vectors. More security patches will be released, more creative hacks will arise; all it takes is a toehold and some creativity. Powerful new features make room for novel vulnerabilities. And so it goes.</p><p>Regarding browsing history, reaction games probably aren’t your <a href="http://en.wikipedia.org/wiki/Global_surveillance_disclosures_(2013%E2%80%93present)">biggest concern</a> anyway. I’ll just <a href="https://www.eff.org/">leave</a> <a href="https://www.torproject.org/">these</a> <a href="https://tails.boum.org/">here</a>.</p><p>And if you made it this far, just <a href="/visited-vectors/reaction/">play the damn game already</a>!</p><h2 id="references">References</h2><ul><li><a href="https://hacks.mozilla.org/2010/03/privacy-related-changes-coming-to-css-vistited/">Mozilla: privacy-related changes coming to CSS :visited</a></li><li><a href="http://tinsnail.neocities.org/">Who Am I</a></li><li><a href="http://www.ieee-security.org/TC/SP2011/PAPERS/2011/paper010.pdf">I still know what you visited last summer</a></li><li><a href="http://lcamtuf.blogspot.ca/2013/05/some-harmless-old-fashioned-fun-with-css.html">Defend your spaceship!</a></li><li><a href="http://saizai.livejournal.com/960791.html">getComputedStyle benchmark</a></li><li><a href="http://www.contextis.com/documents/2/Browser_Timing_Attacks.pdf">Pixel perfect timing attacks with HTML5</a></li><li><a href="http://seclists.org/fulldisclosure/2011/Dec/65">Fast and somewhat reliable cache timing</a></li><li><a href="http://arstechnica.com/security/2012/12/online-marketer-tapped-browser-flaw-to-see-if-visitors-were-pregnant/">History-sniffing in the news (2012)</a></li></ul><h2 id="footnotes">Footnotes</h2><div class="footnotes"><ol><li id="fn:1"><p>A noble effort, but it’s difficult to plug all the <a href="http://arstechnica.com/security/2014/06/theyre-ba-ack-browser-sniffing-ghosts-return-to-haunt-chrome-ie-firefox/">holes</a>. <a href="#fnref:1" class="reversefootnote">&#8617;</a></p></li><li id="fn:2"><p>True under the assumption that the dataset is sparsely populated with <code class="language-css">:visited</code> links. If there is a high percentage of <code class="language-css">:visited</code> links in the set you’re actually better off with the linear algorithm. Good news: counting on a sparse dataset is a very safe bet. <a href="#fnref:2" class="reversefootnote">&#8617;</a></p></li><li id="fn:3"><p>I settled on n = 16 unique links per stack. Adding more links gives a performance hit, as it’s not easy for the browser to composite that many layers (each unique link requires 256 elements). 16 seems to be a sweet-spot. <a href="#fnref:3" class="reversefootnote">&#8617;</a></p></li><li id="fn:4"><p>We can win the same O(logn) complexity with a small optimization: if spacebar is hit on level n and then <em>not</em> on the left branch of level n + 1, we can immediately skip to level n + 2 since we know that our result is on the right side. This works because we only need to check for existence. <a href="#fnref:4" class="reversefootnote">&#8617;</a></p></li><li id="fn:5"><p>Average human reaction time is just over 250ms, so we can safely budget 1s per frame-change. <a href="#fnref:5" class="reversefootnote">&#8617;</a></p></li><li id="fn:6"><p><code class="language-javascript">getComputedStyle</code> could process <a href="http://saizai.livejournal.com/960791.html">200k-3.4M URLs/min</a>. Our test is lucky to get 800 URLs/min. <a href="#fnref:6" class="reversefootnote">&#8617;</a></p></li><li id="fn:7"><p>Some history-sniffing attacks focus on entirely different vectors; a common example is to <a href="http://seclists.org/fulldisclosure/2011/Dec/65">request external resources and time the response</a>, probabilistically determining whether the result was cached. All current approaches that I’ve found (including the ones discussed above) are timing attacks. <a href="#fnref:7" class="reversefootnote">&#8617;</a></p></li><li id="fn:8"><p>I created a quick demo <a href="https://gist.github.com/rileyjshaw/abc13bd2d456669c7d5c">here</a> to inspect painting times in DevTools. <a href="#fnref:8" class="reversefootnote">&#8617;</a></p></li><li id="fn:9"><p>The coolest part of this paper is the second half; they implement OCR for cross-origin iframes using SVG filters. If you enjoyed my article at all (I assume you did since you made it this far) I <em>highly</em> recommend giving <a href="http://www.contextis.com/documents/2/Browser_Timing_Attacks.pdf">Pixel perfect timing attacks with HTML5</a> a read. It’s at least 2 orders of magnitude cooler than my article. <a href="#fnref:9" class="reversefootnote">&#8617;</a></p></li><li id="fn:10"><p>…but just wait until you see the next one. <a href="#fnref:10" class="reversefootnote">&#8617;</a></p></li></ol></div></article><div id="disqus_thread"></div><script>var disqus_shortname = 'rileyjshaw';
          (function() {
              var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
              dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
              (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
          })();</script><a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a><div id="discussion"></div></div></div><footer><strong>Share this:</strong><ul><li><a href="https://twitter.com/home?status=I%20just%20read%20%22Stealing history with CSS binary trees%22%20on%20http://rileyjshaw.com/blog/stealing-history-with-CSS-binary-trees%20and%20it%20legitimately%20changed%20my%20life."><i class="fa fa-twitter"></i></a></li><li><a href="https://www.facebook.com/sharer/sharer.php?u=http://rileyjshaw.com//blog/stealing-history-with-CSS-binary-trees"><i class="fa fa-facebook"></i></a></li></ul></footer><script src="/scripts/script.6400.js"></script></body></html>